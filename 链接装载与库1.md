# 链接

## 构建过程
`预编译 编译 汇编 链接`

编译：
gcc –c SimpleSection.c -c表示只编译不连接

## 编译器做了哪些工作
1. 词法分析 分割成一系列符号
2. 语法分析 生成语法树
3. 语义分析 比如是否合法
4. 目标代码生成优化 生成机器码 删除多余指令 位移代替乘法等


## 为什么要链接
目标文件是未链接过的可执行文件
- 为什么要链接：假如在其他模块中使用了变量定义，分配空间的操作怎么办，于是乎现代编译器将一个源代码文件
编译成一个未链接的目标文件，然后由连接器最终连接起来形成可执行文件


## ELF文件

- 代码段.text：代码所在的段
- 数据段.data和.radata只读数据段：定义分配变量所在的段
- BSS段：声明变量的段

#### 文件头
- 描述了整个文件的属性，是否可执行，静态链接还是动态链接入口地址、目标硬件目标操作系统信息
  版本，运行平台
 `魔数的概念：elf文件开头的几个字节对于a.out,java,#!脚本不一样,这几个标识格式的数称为魔数`
#### 段表
- 描述了各个段信息段名，长度，在文件中的偏移

#### 重定位表
- 代码段和数据段中那些对绝对地址 的引用的位置。

#### 字符串表
- 把字符串集中起来 记录偏移量

#### 符号表
- 变量和函数来说，符号值就是它们的地 址。

#### 调试表
- debug

编译器和连接器在链接过程总如何区分函数重载
符号修饰Name Decoration
符号改编机制Name Mangling


#### 不同编译器之间不能相互链接主要原因之一：
- 不同编译器采用不同的名字修饰方法

#### 强符号和弱符号
c/c++默认函数和初始化了的变量为强符号，但是针对定义，不是针对引用

符号定义规则：
`规则1：不允许强符号被多次定义`
`如果一个符号在某个目标文件中是强符号，在其他文件中都是若符号，则选择强符号`
`规则3：如果都是若符号，那么选择占用空间最大的`

强引用Strong Reference和弱引用Weak Reference：


## 静态链接
静态链接器ld
ld a.o b.o -e main -o ab 静态链接命令
objdump -h a.o
objdump -h b.o

#### 空间和地址分配
在a.o和b.0中看到VMA虚拟地址都是0，因为他们还没有分配虚拟地址
ab的.text和.data段都有地址，说明分配了地址

这个时候文件中各个段在链接侯的虚拟地址就已经确定了。

#### 符号解析和重定位
例如 a.o是怎么应用shared变量和swap函数
反汇编a.o
objdump -d a.o
得知shared变量和swap函数都使用了一个假的地址，把真正的地址计算工作交给了连接器
反汇编ab
objdump -d ab
得到假的地址已经被替换为虚拟地址

#### 重定位表
那么连接器如何知道那些地址需要重定位呢
ELF文件里包含重定位表
查看重定位表objdump -r a.o
查看符号表readelf -s a.o

两个弱符号链接结果为所占空间大的那个弱符号
一个弱一个强结果为强，如果弱的比强的大，那么会发出警告

#### COMMON块


#### C++相关问题
一般c/c++从main开始执行，c++全局对象构造函数是在main之前执行，全局对象的析构函数在main之后
#### 构造函数和析构函数：
- 构造函数：在每次创建类对象之前被调用，和类名称完全相同，不返回任何类型
- 析构函数：在每次删除所创建对象的时候被执行，和类名完全相同，前面加~ (~Line())
linux程序的入口是"_start",这个函数是glibc的一部分

#### 静态库链接
静态库链接，链接glibc

## 可执行文件的装载与进程

#### 进程虚拟地址空间
程序装载到内存就变为进程
虚拟地址空间理论由CPU位数决定 32位 理论4GB地址空间

#### 装载的方式
静态装入：将所需要的指令和数据全部装入内存
动态装入：常用的驻留在内存，一些不常用的存放在磁盘
1. 覆盖装入Overlay和页映射Paging
2. 页映射Paging 需要用到的页装入，当需要都用时使用算法换出

#### 从操作系统角度看可执行文件的装载
进程关键特征：拥有独立的虚拟地址空间
一个进程启动做了什么：
1. 创建一个独立的虚拟地址空间，也就是页映射到物理地址
2. 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系
`这一步是传统意义上的装载，当发生缺页时，物理内存要分配物理页，设置虚拟和物理页映射关系
很重要的一点是，os应该知道所需要的页在可执行文件哪一个位置`
`所以也称可执行文件为镜像`
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动执行
`包括内核堆栈的切换，CPU运行权限的切换`

#### 页错误
`上面步骤完成后，CPU开始打算执行这个指令，发现是个空页面，于是他就认为是页错误，将执行权交给操作系统
在物理内存中分配物理页面建立映射关系，再把控制权返回给进程`

#### 进程虚存空间分布
在链接时候尽量把相同权限属性的多段看作一个segment，一起映射，减少内存浪费
一个进程基本上可以分为如下几种vma区域：
代码VMA，权限只读、可执行；有映像文件。
数据VMA，权限可读写、可执行；有映像文件。
堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展。
栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展。





从“Section”来看ELF就是链接视图，从“Segment”来看就是执行试图

#### linux内核装载ELF文件过程
首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用
执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令
然后execve()系统调用会调用sys_execve,在调用do_execve(),他会查找被执行的文件找到则读取前128个字节，因为里面
包含了他的一些类型和格式信息，然后找到装载他的处理过程，比如elf可执行文件的装载处理过程叫
load_elf_binary(),a.out叫load_aout_binary()


## 动态链接

#### 为什么要动态链接
1.静态链接导致极大的内存和磁盘空间浪费
2.静态链接对程序的更新，部署，发布带来很大麻烦。一个更新，然后都需要进行更新

`动态链接：把程序的模块相互分割开来，形成独立的文件，把连接过程推迟到运行时进行`
a程序需要a.o,c.o b程序需要 b.o,c.o 都需要c.o这个目标文件，那么要运行a时，先加载a.o，然后
发现需要c.o那么加载c.o，当运行b时，发现内存中已经有c.o，就共享c.o
好处：
- 节省内存
- 减少物理页面换入换出，增加cpu缓存命中率，因为不同进程的数据和指令都访问同一个共享模块
- 升级变得容易，当要升级某个模块时，理论上只需要将旧的目标文件覆盖掉无需将所有程序重新链接
- 降低耦合度
- 在运行时可以动态地选择加载各种程序模块，后来的plugin原理
`比如某个公司开发完成了某个产品，它按照一定的规则制定好程序的接口，
其他公司或开发者可以按照这种接口来编写符合要求的动态链接文件。
该产品程序可以动态地载入各种由第三方开发的模块，在程序运行时动态地链接，
实现程序功能的扩展。`
- 加强程序的兼容性

缺点：
- 如果动态链接的模块更新后，新旧接口不兼容，导致原有程序无法运行

##### 动态链接的基本实现
那我们把.o目标文件直接运行时动态链接可以嘛？理论上可行，但实际动态链接方式和使用目标文件略有差别

在linux中ELF动态链接文件被称为共享对象DSO(Dynamic Shared Objects)

实验：
a.c
#include "Lib.h"
int main() { foobar(1); return 0; }
b.c
#include "Lib.h"
int main() { foobar(2); return 0; }
Lib.c
#include <stdio.h>
void foobar(int i) { printf("Printing from Lib.so %d\n", i); }

a和b同时引用Lib，
`编译链接Lib：
gcc -fPIC -shared -o Lib.so Lib.c，"-shared"产生共享对象,
编译a和b
gcc -o a a.c ./Lib.so
gcc -o b b.c ./Lib.so`

简述编译连接过程 Lib.c 编译生成Lib.o，然后和C Runtime Library链接生成Lib.so，a编译生成
a.o 用链接器链接生成a可执行文件，但是这里的链接并没有把Lib.o链接进来。
`让我们再回到动态链接的机制上来，当程序模块Program1.c被编译成为 Program1.o时，
编译器还不不知道 foobar() 函数的地址，这个内容我们已 在静态链接中解释过了。
当链接器将Program1.o链接成可执行文件时， 这时候链接器必须确定Program1.o中所引用的 foobar() 函数的性质。
如果 foobar() 是一个定义与其他静态目标模块中的函数，那么链接器将会按 照静态链接的规则，
将Program1.o中的foobar地址引用重定位；如果 foobar() 是一个定义在某个动态共享对象中的函数，
那么链接器就会将 这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位， 把这个过程留到装载时再进行。`

编译器如何知道foobar是一个动态还是静态符号？
这就是引用Lib.so的原因，Lib.so中保存了完整的符号信息

#### 地址无关代码
装载时重定位：动态链接中多个模块共享一个模块B，如果在链接时给他设置了绝对地址的引用，而这个绝对
地址的引用已经被模块A设置过，那么当有一个程序同时引用B和A时，就会报错

#### 装载时重定位
在链接时不作重定位，而把这步推迟到装载时完成，
"-fPIC"参数的效果
生成地址无关代码

#### 延迟绑定
因为动态链接要GOT定位，符号重定位等，所以比静态链接要慢，所以引入了延迟绑定，即装载的时候
不做重定位，用到的时候才做。
实现方式：
没看懂

#### 动态链接相关结构
动态链接过程：
1. os读取可执行文件头，验证合法性
2. 将头中每个段的虚拟地址，文件地址和属性映射到进程虚拟空间相应位置
`当静态链接的时候，此时os把控制权交给入口地址，程序就开始执行，动态链接稍有不同`
3. os将动态链接器加载到进程地址空间中，将控制权交给动态链接器入口地址，对elf文件进行动态链接
4. 动态链接器将控制权转交给文件入口地址，开始执行


## 共享库
#### 环境变量

linux系统提供了许多方法来改变动态链接器装载共享库路径的方法
LD_LIBRARY_PATH 可以改变共享库装载路径
LD_PRELOAD 会让共享链接器在按照固定规则搜索共享库之前装载

#### 创建共享库
gcc -fPIC -shared -o Lib.so Lib.c


## 内存
### 栈：栈用于维护函数调用的上下文，离开了栈函数调用就没法实现。在 10.2节中将对栈作详细的介绍。
栈通常在用户空间的最高地址处分配， 通常有数兆字节的大小。

栈向低地址增长，看着像是一个倒立的桶，压栈地址是减小，弹栈地址增加，堆向高地址增长。
**栈上包含的数据**
- 函数的返回地址和参数
- 临时变量：包括函数的非静态局部变量以及编译器生成的其他临时变量
- 保存的上下文： 保存在函数调用前后需要保持不变的寄存器

栈上有两个寄存器 ebp和esp esp始终指向栈的顶部，ebp指向函数活动记录的一个固定位置

#### 栈的调用惯例
