

## linux文件系统

文件系统的设计考虑点：
第一点，文件系统要有严格的组织形式，使得文件能够以块为单位进行存储。
`linux操作系统的文件是以块进行存储的，一般块为4K，所以文件被分散成一个一个的块`
第二点，文件系统中也要有索引区，用来方便查找一个文件分成的多个块都存放在了什么位置。
`既然是分散的，那就需要有索引用来找到他们，也就是inode，inode 里面有文件的读写权限 i_mode，属于哪个用户 i_uid，哪个组 i_gid，大小是多少 i_size_io，占用多少个块 i_blocks_io。“某个文件分成几块、每一块在哪里”，这些信息也在 inode 里面，保存在 i_block 里面。`
第三点，如果文件系统中有的文件是热点文件，近期经常被读取和写入，文件系统应该有缓存层。

第四点，文件应该用文件夹的形式组织起来，方便管理和查询。
第五点，Linux 内核要在自己的内存里面维护一套数据结构，来保存哪些文件被哪些进程打开和使用。

##### 一些汇编指令的含义
move a b :把b值赋给a,使a=b
call和ret :call调用子程序，子程序以ret结尾
jmp :无条件跳
int :中断指令
add a b : 加法,a=a+b
or :或运算
xor :异或运算
shl :算术左移
ahr :算术右移
push xxx :压xxx入栈
pop xxx: xxx出栈
inc: 加1
dec: 减1
sub a b : a=a-b
cmp: 减法比较，修改标志位


## linux 内存管理
用户的物理地址对进程不可见，操作系统给进程分配一个虚拟地址，所有进程看到的这个地址都是一样的，里面的内存都是从0开始编号

* 为什么要是用虚拟地址?
直接使用物理地址的缺陷：
1. 地址空间不隔离。所有程序直接访问物理地址，恶意程序很容易篡改，或者有些程序修改了其他程序的数据，就会造成其他程序崩溃
2. 内存使用率低。频繁的换入换出，如果C程序很大，当C运行时就需要将A,B都换出。
    `这个通过虚拟地址隔离的分页功能实现，把虚拟地址空间按页分割，常用的放到物理内存，不常用的放到磁盘，需要用时取出，可以实现内存共享，`
    那既然不是说是隔离的，为什么又说共享？
        同一块物理内存可以被多个程序共享，也就是多个程序的虚拟地址可以使用同一块物理地址，但是同一时刻是独占的，有操作系统进行调度。可以换出A的虚拟页，加载B的虚拟页，这两个页映射的物理地址是同一块
3. 程序运行地址不确定。程序每次运行时，我们都需要给他分配一块空闲区域，这块区域是不确定的，给程序编写造成许多麻烦。
4. 使用虚拟地址只要妥善处理好虚拟地址到物理地址的映射过程，就能达到隔离


### 分页
分页是把地址空间分成固定大小的页，虚拟地址空间和物理地址是同样的分法，都是4KB一页

### 装载执行步骤
* 可执行文件的装载，也就是程序的运行:
1. 建立虚拟地址空间和物理内存的映射，创建这样一个数据结构，而不是真正的映射上。当发生缺页中断的时候才映射(由伙伴系统进行映射)
2. 建立虚拟地址空间和可执行文件的映射，
3. 将cpu指令寄存器设置成可执行文件的入口，启动运行

### 页错误

当发现页面不存在时：
1. 如果内存中有空闲的物理页面，则分配一物理页帧r，然后转第4步，否则转第2步；
2. 选择某种页面置换算法，选择一个将被替换的物理页帧r，它所对应的逻辑页为q，如果该页在内存期间被修改过，则需把它写回到外存；
3. 将q所对应的页表项进行修改，把驻留位置0；
4. 查询可执行文件和虚拟页面的映射关系的数据结构，找到缺页所在的VMA，计算出偏移，将需要访问的页p装入到物理页面r中；
5. 修改p所对应的页表项的内容，把驻留位置1，把物理页帧号置为x；
6. 重新运行被中断的指令。
