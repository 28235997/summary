# 网络协议与wireshark
## arp协议
1. 在网络数据传输中，网络层会对传输层的数据进行封包形成ip包，只关心目标机器的ip
2. ip包被封装在以太网帧中，经过物理层(网卡)发送到网络上
3. 到达目标所在的局域网之后，以太网帧又是根据目的MAC地址来找到目的网卡的
   局域网中的所有网卡都会接收到这个帧，而只有帧头部的目的mac和自己网卡的mac匹配时才将此帧交付上层协议栈，否则丢弃该帧
4. 所以以太网帧里是需要目的mac的，然而主机刚连接到局域网时是不知道目的mac的，
5. 需要发送一个arp请求数据包，获得目的主机的mac地址，记录到arp表中
`(arp数据包也是被包含在以太网帧中的，发送时，帧头部中的目的mac地址填写为0xffffffff，表示在本地局域网上广播，这样属于该局域网的所有机器接收到一个广播帧的时候都会向协议栈递交这个帧中的数据包，这里是arp数据包)`

6. 找到先前缺少的mac地址而暂存的数据包，并用以太网帧封装他，填充目的mac地址域


1. 内核通过代码实现网络协议栈，硬件监听物理介质，进行数据的接收。
2. 当数据填满了缓冲区，就会产生中断
3. 中断产生后，系统会转向终端服务子程序，从硬件缓冲区复制到内核缓冲区

## HTTP协议
### 字段
* Host 指定服务器域名
* content-length 服务器再返回时表明本次回应的数据长度，值是Keep-Alive 
* Content-Type 用于回应时告诉客户端数据格式
* Content-Encoding 说明内容的压缩格式 客户端，Accept-Encoding: gzip, deflate

### GET POST
* GET 从服务端获取数据，是安全和幂等的，因为是获取数据
* POST 向服务端提交数据，是不安全的，因为要修改数据，不幂等的，多次提交结果不同

### HTTP/1.1
1. 长连接，不需要每次请求都重新建立tcp连接。
2. 无状态，不会记录登陆状态，也就是登录信息，所以有了cookie，session
3. 不安全
4. 管道网络传输，第一个请求发出去不必等响应就可以发第二个请求
### HTTP/2 改进
1. 多路复用，多个http请求复用一个tcp连接
2. 二进制格式
3. 数据流
4. 头部压缩，多个请求头一样只记录索引号

### http提高性能策略
1. 缓存
http为了提高性能，在第一次请求时会将响应的内容缓存到本地磁盘，以url:body的形式，下次请求就可以直接直接使用缓存，
但是当服务器的内容更新了怎么办？
有一个过期时间，时间过了会重新请求，当重新请求内容没变时(判断变没变有一个摘要，类似md5摘要)，返回的是一个304 Not Modified的不带body体的响应。
2. 减少请求次数
3. 压缩响应资源



### tcp keepalive和http keepalive区别
HTTP协议的Keep-Alive意图在于TCP连接复用，同一个连接上串行方式传递请求-响应数据；TCP的Keepalive机制意图在于探测连接的对端是否存活。

## TCP协议
[TCP是⾯向连接的(一对一才能连接，不能同时发给多个主机)、可靠的(能保证可靠到达)、基于字节流(消息无边界，多少都可以发)的传输层通信协议]
### TCP协议头部格式
源端口号(16位)|目的端口号(16位)
序列号(32位)
确认应答号(32位)
首部长度(4位)|保留位(6位)URG|ACK|PSH|PST|SYN|FIN|窗口大小(16位)
校验和(16位)|紧急指针(16位)
选项
数据

* 序列号 解决包乱序问题
* 应答号 解决丢包问题
* ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。
* RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
* SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。
* FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主机之间就可以相互交换 FIN 位为 1 的 TCP 段

### 三次握手分析
第一次：发送SYN的序列号seq=51276(把报文的SYN置为1)  客户端处于SYN_SENT状态
第二次：发送ACK=51276+1用来确认SYN报文(把SYC,ACK置为1)，并发送自己的SYN的seq=25606  服务端发送完处于SYN_RECV
第三次：发送ACK=25606+1来确认服务端的ACK报文 发送完客户端处于ESTABLISHED 状态，服务端收到ack后也变为ESTABLISHED 状态
到此建立连接

#### 三次握手与socket编程接口的关系
客户端connect之后相当于第二次握手返回，然后客户端进入establish状态，此时服务端的accept函数一直处于阻塞状态
客户端发送ACK报文，到达服务端后accept阻塞函数返回

#### 为什么要三次握手
最主要原因是放置重复历史连接导致连接混乱，当发起一个连接，因为网络问题一直没有响应就发起了一个新的连接100，这个时候旧的连接先到了，序列号90，当服务端返回的确认号是91，客户端就会知道这个不是一个正确的连接，则会把rst置为1 终止连接，然后新的连接到了就正常了

### 四次挥手
第一次：客户端发送FIN,ACK包，seq=78657
第二次：服务端发送ACK包，ack=78657+1
第三次：服务端发送FIN包，seq=98756
第四次：客户端发送ACK包，ack=98756+1
到此断开连接，抓包可能会发现只有三次挥手，那是因为服务端如果也没有数据要发送了，第二次和第三次合并在一起了

- 当主动⽅关闭连接时，会发送 FIN 报⽂，此时发送⽅的 TCP 连接将从 ESTABLISHED 变成 FIN_WAIT1。
- 当被动⽅收到 FIN 报⽂后，内核会⾃动回复 ACK 报⽂，连接状态将从 ESTABLISHED 变成 CLOSE_WAIT，表示被动⽅在等待进程调⽤ close 函数关闭连接。
- 当主动⽅收到这个 ACK 后，连接状态由 FIN_WAIT1 变为 FIN_WAIT2，也就是表示主动⽅的发送通道就关闭了。
- 当被动⽅进⼊ CLOSE_WAIT 时，被动⽅还会继续处理数据，等到进程的 read 函数返回 0 后，应⽤程序就会调⽤ close 函数，进⽽触发内核发送 FIN 报⽂，此时被动⽅的连接状态变为 LAST_ACK。
- 当主动⽅收到这个 FIN 报⽂后，内核会回复 ACK 报⽂给被动⽅，同时主动⽅的连接状态由 FIN_WAIT2 变为TIME_WAIT，在 Linux 系统下⼤约等待 1 分钟后，TIME_WAIT 状态的连接才会彻底关闭。
- 当被动⽅收到最后的 ACK 报⽂后，被动⽅的连接就会关闭。

### 保活机制
在一个时间段内，没有任何连接相关活动，会触发tcp保活机制，每隔一段时间发送探测报文，如果没有收到，则认为tcp连接已经死亡，将上报给应用程序
net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75  
net.ipv4.tcp_keepalive_probes=9

### 快速连接
常规的HTTP请求，一个完整的交互过程，需要2.5个RTT时延(三次握手1.5个 请求一次返回一次，一共2.5个)
在linux3.7内核版本中，提供了TCP Fast Open功能，在第一次建立连接时的第二次握手，服务端会给客户端发送一个cookie在下次请求的时候，客户端在 SYN 包带上 Cookie 发给服务端，就提前可以跳过三次握手的过程，因为 Cookie 中维护了一些信息，服务端可以从 Cookie 获取 TCP 相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；

### 重复确认和快速重传
当接收方收到乱序数据包时，会发送重复的 ACK，以便告知发送方要重发该数据包，当发送方收到 3 个重复 ACK 时，就会触发快速重传，立刻重发丢失数据包。
重传的wireshark标识：
发送重复的ACK：[TCP Dup ACK 多少号包#第几次发送] 例如[TCP Dup ACK 52#2]
重传包：[TCP Fast Retransmission] 

### 流量控制
流量控制就是滑动窗口
### 拥塞控制
避免发送方的数据填满整个接收方的缓存
- 慢启动
开始时，发送一个MSS大小的数据，ack确认后发送窗口swnd变为两个，四个，8个
- 拥塞避免
当上升到慢启动门限ssthresh(阈值)时，使用拥塞避免算法，由指数增长变为线性增长，每次增加 1/swnd，也就是1
- 拥塞发生
当增加到一定程度就会发生拥塞，也就是丢白，超时重传，就进入了拥塞发生算法
- 快速恢复


### 滑动窗口
发送窗口：tcp一次可以发送多个MSS(Maximum Segment Size),mss加上 tcp头和ip头就得到MTU(最大传输单元)，
网络影响tcp的传输速度，那怎么知道一次发送多少个mss呢？目的是尽量不出现拥塞，出现就可能丢包
* 慢启动：
如果发出去的包都得到确认，表明还没有达到拥塞点，可以增大拥塞窗口。
由于这个阶段发生拥塞的概率很低，所以增速应该快一些。RFC 建议的算法是每
收到 n 个确认，可以把拥塞窗口增加 n 个 MSS。比如发了 2 个包之后收到 2 个确
认，拥塞窗口就增大到 2+2=4，接下来是 4+4=8, 8+8=16……这个过程的增速很快，
但是由于基数低，传输速度还是比较慢的，所以被称为慢启动过程。
* 拥塞避免
当慢启动到一定程度，就不能继续加倍了，要一次加一个mss，称为拥塞避免

* 超时重传
如果一段时间收不到包，就认定包丢失，就会引发超时重传，重传之后重新进入慢启动，一个mss

### 超时重传
如果发生丢包了，会引发超时重传，时间是指数递增的重传时间与次数的关系为  2^n-1
第三次就是2^3-1=7秒，在7秒重传
重传次数在内核文件cat /proc/sys/net/ipv4/tcp_syn_retries，tcp_synack_retries(第二次握手的超时重传次数)，/proc/sys/net/ipv4/tcp_retries2(建立连接后的数据包超时重传次数)



### 快速重传
当发送三次相同的ack，则认为发生了丢包，不必等到超时在重传
* 可以清晰的看到tcp流的时序，可以点击统计->流量图->流类型选择TCP，

### tcp协议的性能优化
1. 三次握手的优化
客户端：降低tcp的重传次数
服务端：在全连接队列满时通知客户端 connection reset by peer  在内核参数/proc/sys/net/ipv4/tcp_abort_on_overflow 中配置 ，0时扔掉这个ack，但可以重传ack，1时，直接废掉这个连接。
         开启fast open，直接以cookie校验的方式代替三次握手  /proc/sys/net/ipv4/tcp_fastopen 0：关闭，1：作为客户端时开启，2：作为服务端时开启，3：都开启
2. 四次挥手的优化
 - 当发送了FIN报文之后，进入FIN_WAIT1状态，如果没有收到ack，会一直重发，降低重发次数/proc/sys/net/ipv4/tcp_orphan_retires
 - 当进程调用close关闭连接，此连接就会变成孤儿连接，内核参数可以控制最大的孤儿连接数，超过直接发送RST复位报文强制关闭  /proc/sys/net/ipv4/tcp_max_orphan  控制孤儿连接数
 - TIME_WAIT状态的优化：当TIME_WAIT连接数量大于某个值时，关闭连接不在进入TIME_WAIT状态，直接关闭，这个值在/proc/sys/net/ipv4/tcp_max_tw_buckets.当并发连接数过多时，调大。   为什么是60秒？
            1. 防止具有相同四元组的旧的包被收到：
            2. 保证被动连接的一方被正确的关闭，即保证最后的ACK能让被动关闭方接收  
3. 数据传输的优化
TCP报文发出后，内核并不会立刻删除它，因为重传的时候还需要
滑动窗口影响网络传输速率

使用netstat -tunlp 
t tcp
u udp
n 和tcpdump命令的-n一样，显示主机地址，而不是机器名
l 只显示监听的 
a 显示所有
p显示pid和程序名

## UDP协议
udp包头较小，只有端口号，包长度，校验码等
udf没有重传机制，比如6个包丢一个包，只能重传所有包，而tcp只用重传丢失的一个包即可。
## DNS
DNS的递归查询和迭代查询
递归：先查询根域名服务器，然后根域名服务器查询权威域名服务器 由根域名服务器返回结果
迭代：先查询根域名服务器，然后根域名服务器告诉我要查询权威域名服务器，然后查询权威域名服务器，返回结果

### dns过程
首先去找根域名服务器，再找顶级域名服务器，再找权威域名服务器，返回结果。缓存到本地的dns缓存

## IP协议
IP地址划分：
A类： 0.0.0.0-127.255.255.255   
B类： 128.0.0.0-191.255.255.255
C类： 192.0.0.0-223.255.255.255

怎么区分那类地址：
if 第一位是0：
   A类
elif 第二位是0：
   B类
elif 第三位是0：
   C类
elif 第四位是0：
   D类
else：
   E类

### CIDR
为什么要分离网络号和主机号：
因为两台计算机要通讯，⾸先要判断是否处于同⼀个⼴播域内，即⽹络地址是否相同。如果⽹络地址相同，表明接收⽅在本⽹络上，那么可以把数据包直接发送到⽬标主机。
子网掩码是为了隔离广播域的。

### DHCP
广播发送discover报文，返回offer报文，从中选一个，发送request报文，回复ACK

## 协议栈
封包，从应用层封到数据链路层，然后用网卡将包顺着电线发出去
### 交换机
工作在数据链路层，是二层网络设备


