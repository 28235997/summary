# 网络协议与wireshark
## arp协议
1. 在网络数据传输中，网络层会对传输层的数据进行封包形成ip包，只关心目标机器的ip
2. ip包被封装在以太网帧中，经过物理层(网卡)发送到网络上
3. 到达目标所在的局域网之后，以太网帧又是根据目的MAC地址来找到目的网卡的
   局域网中的所有网卡都会接收到这个帧，而只有帧头部的目的mac和自己网卡的mac匹配时才将此帧交付上层协议栈，否则丢弃该帧
4. 所以以太网帧里是需要目的mac的，然而主机刚连接到局域网时是不知道目的mac的，
5. 需要发送一个arp请求数据包，获得目的主机的mac地址，记录到arp表中
`(arp数据包也是被包含在以太网帧中的，发送时，帧头部中的目的mac地址填写为0xffffffff，表示在本地局域网上广播，这样属于该局域网的所有机器接收到一个广播帧的时候都会向协议栈递交这个帧中的数据包，这里是arp数据包)`

6. 找到先前缺少的mac地址而暂存的数据包，并用以太网帧封装他，填充目的mac地址域


1. 内核通过代码实现网络协议栈，硬件监听物理介质，进行数据的接收。
2. 当数据填满了缓冲区，就会产生中断
3. 中断产生后，系统会转向终端服务子程序，从硬件缓冲区复制到内核缓冲区


## TCP协议

### 三次握手分析
第一次：发送SYN的序列号seq=51276  客户端处于SYN_CENT状态
第二次：发送ACK=51276+1用来确认SYN报文，并发送自己的SYN的seq=25606  服务端发送完处于SYN_RECV
第三次：发送ACK=25606+1来确认服务端的SYN报文 发送完客户端处于ESTABLISHED 状态，服务端收到ack后也变为ESTABLISHED 状态
到此建立连接

### 四次挥手
第一次：客户端发送FIN,ACK包，seq=78657
第二次：服务端发送ACK包，ack=78657+1
第三次：服务端发送FIN包，seq=98756
第四次：客户端发送ACK包，ack=98756+1
到此断开连接，抓包可能会发现只有三次挥手，那是因为服务端如果也没有数据要发送了，第二次和第三次合并在一起了

### 超时重传
如果发生丢包了，会引发超时重传，时间是指数递增的重传时间与次数的关系为  2^n-1
第三次就是2^3-1=7秒，在7秒重传
重传次数在内核文件cat /proc/sys/net/ipv4/tcp_syn_retries，tcp_synack_retries，/proc/sys/net/ipv4/tcp_retries2

* 可以清晰的看到tcp流的时序，可以点击统计->流量图->流类型选择TCP，

使用netstat -tunlp 
t tcp
u udp
n 和tcpdump命令的-n一样，显示主机地址，而不是机器名
l 只显示监听的 
a 显示所有
p显示pid和程序名

### 保活机制
在一个时间段内，没有任何连接相关活动，会触发tcp保活机制，每隔一段时间发送探测报文，如果没有收到，则认为tcp连接已经死亡，将上报给应用程序
net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75  
net.ipv4.tcp_keepalive_probes=9

### 快速连接
常规的HTTP请求，一个完整的交互过程，需要2.5个RTT时延(三次握手1.5个 请求一次返回一次，一共2.5个)
在linux3.7内核版本中，提供了TCP Fast Open功能，在第一次建立连接时的第二次握手，服务端会给客户端发送一个cookie在下次请求的时候，客户端在 SYN 包带上 Cookie 发给服务端，就提前可以跳过三次握手的过程，因为 Cookie 中维护了一些信息，服务端可以从 Cookie 获取 TCP 相关的信息，这时发起的 HTTP GET 请求就只需要 1 个 RTT 的时延；

### 重复确认和快速重传
当接收方收到乱序数据包时，会发送重复的 ACK，以便告知发送方要重发该数据包，当发送方收到 3 个重复 ACK 时，就会触发快速重传，立刻重发丢失数据包。
重传的wireshark标识：
发送重复的ACK：[TCP Dup ACK 多少号包#第几次发送] 例如[TCP Dup ACK 52#2]
重传包：[TCP Fast Retransmission] 

### 流量控制


### 滑动窗口
发送窗口：tcp一次可以发送多个MSS(Maximum Segment Size),mss加上 tcp头和ip头就得到MTU(最大传输单元)，
网络影响tcp的传输速度，那怎么知道一次发送多少个mss呢？目的是尽量不出现拥塞，出现就可能丢包
* 慢启动：
如果发出去的包都得到确认，表明还没有达到拥塞点，可以增大拥塞窗口。
由于这个阶段发生拥塞的概率很低，所以增速应该快一些。RFC 建议的算法是每
收到 n 个确认，可以把拥塞窗口增加 n 个 MSS。比如发了 2 个包之后收到 2 个确
认，拥塞窗口就增大到 2+2=4，接下来是 4+4=8, 8+8=16……这个过程的增速很快，
但是由于基数低，传输速度还是比较慢的，所以被称为慢启动过程。
* 拥塞避免
当慢启动到一定程度，就不能继续加倍了，要一次加一个mss，称为拥塞避免

* 超时重传
如果一段时间收不到包，就认定包丢失，就会引发超时重传，重传之后重新进入慢启动，一个mss

## UDP协议
udp包头较小，只有端口号，包长度，校验码等
udf没有重传机制，比如6个包丢一个包，只能重传所有包，而tcp只用重传丢失的一个包即可。
## DNS
DNS的递归查询和迭代查询
递归：先查询根域名服务器，然后根域名服务器查询权威域名服务器 由根域名服务器返回结果
迭代：先查询根域名服务器，然后根域名服务器告诉我要查询权威域名服务器，然后查询权威域名服务器，返回结果


