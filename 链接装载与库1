# 链接

## 构建过程
`预编译 编译 汇编 链接`

## 编译器做了哪些工作
1. 词法分析 分割成一系列符号
2. 语法分析 生成语法树
3. 语义分析 比如是否合法
4. 目标代码生成优化 生成机器码 删除多余指令 位移代替乘法等


## 为什么要链接
目标文件是未链接过的可执行文件
- 为什么要链接：假如在其他模块中使用了变量定义，分配空间的操作怎么办，于是乎现代编译器将一个源代码文件
编译成一个未链接的目标文件，然后由连接器最终连接起来形成可执行文件


## ELF文件

- 代码段.text：代码所在的段
- 数据段.data和.radata只读数据段：定义分配变量所在的段
- BSS段：声明变量的段

### 文件头
- 描述了整个文件的属性，是否可执行，静态链接还是动态链接入口地址、目标硬件目标操作系统信息
  版本，运行平台

### 段表
- 描述了各个段信息段名，长度，在文件中的偏移

### 重定位表
- 代码段和数据段中那些对绝对地址 的引用的位置。

### 字符串表
- 把字符串集中起来 记录偏移量

### 符号表
- 变量和函数来说，符号值就是它们的地 址。

### 调试表
- debug

编译器和连接器在链接过程总如何区分函数重载
符号修饰Name Decoration
符号改编机制Name Mangling


###不同编译器之间不能相互链接主要原因之一：
- 不同编译器采用不同的名字修饰方法

### 强符号和弱符号
c/c++默认函数和初始化了的变量为强符号，但是针对定义，不是针对引用

符号定义规则：
`规则1：不允许强符号被多次定义`
`如果一个符号在某个目标文件中是强符号，在其他文件中都是若符号，则选择强符号`
`规则3：如果都是若符号，那么选择占用空间最大的`

强引用Strong Reference和弱引用Weak Reference：


## 静态链接

ld a.o b.o -e main -o ab 静态链接命令
objdump -h a.o
objdump -h b.o

### 空间和地址分配
在a.o和b.0中看到VMA虚拟地址都是0，因为他们还没有分配虚拟地址
ab的.text和.data段都有地址，说明分配了地址

这个时候文件中各个段在链接侯的虚拟地址就已经确定了。

### 符号解析和重定位
例如 a.o是怎么应用shared变量和swap函数
反汇编a.o
objdump -d a.o
得知shared变量和swap函数都使用了一个假的地址，把真正的地址计算工作交给了连接器
反汇编ab
objdump -d ab
得到假的地址已经被替换为虚拟地址

### 重定位表
那么连接器如何知道那些地址需要重定位呢
ELF文件里包含重定位表
查看重定位表objdump -r a.o
查看符号表readelf -s a.o

两个弱符号链接结果为所占空间大的那个弱符号
一个弱一个强结果为强，如果弱的比强的大，那么会发出警告

### COMMON块


### C++相关问题
一般c/c++从main开始执行，c++全局对象构造函数是在main之前执行，全局对象的析构函数在main之后
#### 构造函数和析构函数：
- 构造函数：在每次创建类对象之前被调用，和类名称完全相同，不返回任何类型
- 析构函数：在每次删除所创建对象的时候被执行，和类名完全相同，前面加~ (~Line())
linux程序的入口是"_start",这个函数是glibc的一部分

### 静态库链接
静态库链接，链接glibc

## 可执行文件的装载与进程

### 进程虚拟地址空间
程序装载到内存就变为进程
虚拟地址空间理论由CPU位数决定 32位 理论4GB地址空间

### 装载的方式
静态装入：将所需要的指令和数据全部装入内存
动态装入：常用的驻留在内存，一些不常用的存放在磁盘
1. 覆盖装入Overlay和页映射Paging
2. 页映射Paging 需要用到的页装入，当需要都用时使用算法换出

### 从操作系统角度看可执行文件的装载
进程关键特征：拥有独立的虚拟地址空间
一个进程启动做了什么：
1. 创建一个独立的虚拟地址空间，也就是页映射到物理地址
2. 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系
`这一步是传统意义上的装载，当发生缺页时，物理内存要分配物理页，设置虚拟和物理页映射关系
很重要的一点是，os应该知道所需要的页在可执行文件哪一个位置`
`所以也称可执行文件为镜像`
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动执行
`包括内核堆栈的切换，CPU运行权限的切换`

### 页错误
`上面步骤完成后，CPU开始打算执行这个指令，发现是个空页面，于是他就认为是页错误，将执行权交给操作系统
在物理内存中分配物理页面建立映射关系，再把控制权返回给进程`

### 进程虚存空间分布
在链接时候尽量把相同权限属性的多段看作一个segment，一起映射，减少内存浪费
一个进程基本上可以分为如下几种vma区域：
代码VMA，权限只读、可执行；有映像文件。
数据VMA，权限可读写、可执行；有映像文件。
堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展。
栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展。


从“Section”来看ELF就是链接视图，从“Segment”来看就是执行试图
