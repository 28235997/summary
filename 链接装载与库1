# 链接

## 构建过程
`预编译 编译 汇编 链接`

## 编译器做了哪些工作
1. 词法分析 分割成一系列符号
2. 语法分析 生成语法树
3. 语义分析 比如是否合法
4. 目标代码生成优化 生成机器码 删除多余指令 位移代替乘法等


## 为什么要链接
目标文件是未链接过的可执行文件
- 为什么要链接：假如在其他模块中使用了变量定义，分配空间的操作怎么办，于是乎现代编译器将一个源代码文件
编译成一个未链接的目标文件，然后由连接器最终连接起来形成可执行文件


## ELF文件

- 代码段.text：代码所在的段
- 数据段.data和.radata只读数据段：定义分配变量所在的段
- BSS段：声明变量的段

### 文件头
- 描述了整个文件的属性，是否可执行，静态链接还是动态链接入口地址、目标硬件目标操作系统信息
  版本，运行平台

### 段表
- 描述了各个段信息段名，长度，在文件中的偏移

### 重定位表
- 代码段和数据段中那些对绝对地址 的引用的位置。

### 字符串表
- 把字符串集中起来 记录偏移量

### 符号表
- 变量和函数来说，符号值就是它们的地 址。

### 调试表
- debug

编译器和连接器在链接过程总如何区分函数重载
符号修饰Name Decoration
符号改编机制Name Mangling


###不同编译器之间不能相互链接主要原因之一：
- 不同编译器采用不同的名字修饰方法

### 强符号和弱符号
c/c++默认函数和初始化了的变量为强符号，但是针对定义，不是针对引用

符号定义规则：
`规则1：不允许强符号被多次定义`
`如果一个符号在某个目标文件中是强符号，在其他文件中都是若符号，则选择强符号`
`规则3：如果都是若符号，那么选择占用空间最大的`

强引用Strong Reference和弱引用Weak Reference：


## 静态链接

ld a.o b.o -e main -o ab 静态链接命令
objdump -h a.o
objdump -h b.o

### 空间和地址分配
在a.o和b.0中看到VMA虚拟地址都是0，因为他们还没有分配虚拟地址
ab的.text和.data段都有地址，说明分配了地址

这个时候文件中各个段在链接侯的虚拟地址就已经确定了。

### 符号解析和重定位
例如 a.o是怎么应用shared变量和swap函数
反汇编a.o
objdump -d a.o
得知shared变量和swap函数都使用了一个假的地址，把真正的地址计算工作交给了连接器
反汇编ab
objdump -d ab
得到假的地址已经被替换为虚拟地址

### 重定位表
那么连接器如何知道那些地址需要重定位呢
ELF文件里包含重定位表
查看重定位表objdump -r a.o
查看符号表readelf -s a.o

两个弱符号链接结果为所占空间大的那个弱符号
一个弱一个强结果为强，如果弱的比强的大，那么会发出警告

### COMMON块


### C++相关问题
一般c/c++从main开始执行，c++全局对象构造函数是在main之前执行，全局对象的析构函数在main之后
#### 构造函数和析构函数：
- 构造函数：在每次创建类对象之前被调用，和类名称完全相同，不返回任何类型
- 析构函数：在每次删除所创建对象的时候被执行，和类名完全相同，前面加~ (~Line())
linux程序的入口是"_start",这个函数是glibc的一部分

### 静态库链接
静态库链接，链接glibc
