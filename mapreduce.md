### 编程模型
MapReduce编程模型原理：利用一个输入key/value pair集合来产生一个key/value pair的输出集合
用户自定义的
Map函数接受一个输入的key/value pair值，然后产生一个中间key/value pair值的集合。MapReduce库把所有具有相同中间key值I的中间value值集合在一起后传递给reduce函数。


例子：
计算URL访问频率：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。
说白了就是 map的输入 (文件，url)-->(url,1)的list
reduce 输入(url,1)的list-->(url,记录总数)的list结果


### 实现
1. 用户程序先调用mapreduce的库将输入文件分片，每个一般16M或64M
2. 由master进行任务分配，分配给worker，
3. 被分配了map任务的worker程序读取相关的输入数据，解析出 key/value (对于例子，也就是从文件中拿到url)，传递给map函数，处理生成中间结果缓存在内存中
4. 缓存中的key/value pair通过分区函数分成R个区域，周期性的写入磁盘，存储位置被回传给master，由master传给reduce worker
5. reduce worker接收到mater程序发来的存储位置信息后，用RPC读取，之后将key排序(必须，因为许多不同key被分配到同一个reduce worker)，如果排序数据太大，内存无法完成，则在外部进行排序
6. reduce worker遍历排序后中间结果，传给reduce函数
7. 唤醒用户程序

##### master数据结构
他存储每个map和reduce的状态，空闲，工作，完成，以及worker机器的标识，他像一个管道

##### 容错
worker故障：master周期性ping每一个worker，如果一段时间内没有收到返回信息，则标记为失效，将他们承担的任务设置为初始，分配到其他worker，重新执行
master故障：master失效就终止计算，客户可以检查到这个状态，启动重新执行

失效处理机制：当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，我们的分布式实现在任何情况下的输出都和所有程序没有出现何错误、顺序的执行产生的输出是一样的。
如果是原子操作，则写入到一个临时文件，如果都执行完了，在重命名。

#### 存储位置
网络带宽是相对匮乏的资源，尽量把输入数据存储在本地磁盘上来节省网络带宽，分配任务尽量将任务分配在包含相关数据的机器上

#### 任务粒度
理想情况下，粒度越小，越能提高性能，提高负载均衡能力，加快故障修复，但有一定的客观限制，因为master要执行 O(M+R)次调度，O(M*N)个状态，
我们把R值设置为我们想使用的worker机器数量的小的倍数。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。

#### 备用任务
木桶效应，时间取决于那个执行最慢的，所以，当接近完成的时候，就让backup任务启动，无论谁完成了，都标记为已完成，通常只占用多几个百分点的资源，但是能收获奇效。

### 技巧

使用分区函数：
比如用hash算法，hash可以均衡的分区，比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的用户需要提供专门的分区函数。例如，使用“hash(Hostname(urlkey))mod R”作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。

保证顺序：
保证有序很有帮助

Combiner函数：
每个map任务将产生成千上万的中间结果，然后通过网络传输到reduce程序，进行计算，我们允许用户传入一些可选的combiner函数，先做一次合并，然后再通过网络发送出去。


跳过损坏的记录：
当执行大数据量的分析，一些问题忽略掉也是可以接受的，所以mapreduce提供了一种模式，跳过导致crash的记录不处理。


### 性能